---

layout: page
title: 红宝书笔记（一）：变量、作用域与内存
date: 2021-01-18 19:04:31
tags: 
  - 前端JS
  - 前端基础
categories: 红宝书笔记

---

# 第四章 变量、作用域与内存

> 重点掌握：
>
> 1. 变量使用的原始值与引用值;
> 2. 理解执行上下文;
> 3. 理解垃圾回收；

## 4.1 原始值与引用值

原始值：

- **按值访问，**操作的是实际值；

-  6种原始值类型Undefined、 Null、 Boolean、 Number、 String 和 Symbol。

引用值：

- 保存在内存的对象，j s不允许直接访问操作对象的内存空间；

- 访问的是对象的引用，不是实际对象本身；

### 4.1.1 动态属性

原始值不能有属性，添加也会报undefined；

只有引用值可以动态添加属性；

> 注意：如果使用new关键字，则js会创建一个Object类型的实例，但行为类似原始值。

```javascript
let name1 = "Nicholas";
let name2 = new String("Matt");
name1.age = 27;
name2.age = 26;
console.log(name1.age); // undefined
console.log(name2.age); // 26
console.log(typeof name1); // string
console.log(typeof name2); // object
```

### 4.1.2 复制

原始值：复制一个副本。完全独立，互不干扰。

引用值：复制的是一个指针，指向存储在堆内存的对象。指向同一对象。

### 4.1.3 传递参数

​		ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。

​		在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。

> **证明引用类型也是按值传递**
>
> ```javascript
> function setName(obj) {
> obj.name = "Nicholas";
> obj = new Object(); // +
> obj.name = "Greg"; // +
> }
> let person = new Object();
> setName(person);
> console.log(person.name); // "Nicholas"
> ```
>
> ​		这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为"Nicholas"。然后变量 obj 被设置为一个新对象且 name 属性被设置为"Greg"。
>
> ​		如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为"Greg"的对象。可是，当我们再次访问 person.name 时， 它的值是"Nicholas"，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。

### 4.1.4 确定类型

确定类型： typeof判断原始值；instanceof判断引用值；

------

## 4.2 执行上下文与作用域

​		变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的**变量对象**（ variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

	通过var定义的全局变量和函数都会成为window对象的属性和方法；
	
	使用let和const的顶级声明则不会挂载到window对象上；

​		函数上下文：（包括定义在上面的所有变量和函数）在其所有代码都执行完毕后会被销毁；

​		全局上下文：在应用程序退出前才会被销毁，比如关闭网页或退出浏览器；

### 4.2.1 作用域增强《没有太懂》

​		某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：
​		 try/catch 语句的 catch 块
​		 with 语句
​		这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

### 4.2.2 变量声明

#### 1. 使用var的函数作用域声明

- 变量会自动添加到最接近的上下文；

- 如若未经声明就被初始化，则自动添加到全局上下文，函数退出后变量依然存在，可访问；这种现象叫**“提升”**。

  > 初始化变量之前一定要先声明，严格模式下，会报错。

- 声明之前打印变量，提升意味着会输出undefined而不是Reference Error；

  ```javascript
  console.log(name); // undefined
  var name = 'Jake';
  function() {
    console.log(name); // undefined
    var name = 'Jake';
  }
  ```

#### 2. 使用let的*块级*作用域声明

- 块级作用域由最近的一堆包含花括号{}界定。换句话说， if 块、 while 块、 function 块，甚至连单独的块也是 let 声明变量的作用域。

  ```javascript
  // 这不是对象字面量，而是一个独立的块
  // JavaScript 解释器会根据其中内容识别出它来
  {
  let d;
  }
  console.log(d); // ReferenceError: d 没有定义
  ```

- let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。

- let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，

  > 这种情况应该避免。来看下面两个例子：
  >
  > ```javascript
  > for (var i = 0; i < 10; ++i) {}
  > console.log(i); // 10
  > for (let j = 0; j < 10; ++j) {}
  > console.log(j); // ReferenceError: j 没有定义
  > ```
  >
  > 严格来讲， let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（ temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说， let 的提升跟 var是不一样的。

#### 3. 使用const的常量声明

​		使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。

​		若为引用值，则对象的键不受限制。

```javascript
const o1 = {};
o1 = {}; // TypeError: 给常量赋值
const o2 = {};
o2.name = 'Jake';
console.log(o2.name); // 'Jake'
```

​		如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：

```javascript
const o3 = Object.freeze({});
o3.name = 'Jake';
console.log(o3.name); // undefined
```

由于 const 声明暗示变量的值是单一类型且不可修改， JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。

> 推荐：开发流中应尽可能地多使用const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug。
>
> JavaScript 运行时编译器对于const声明，可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。

------

## 4.3 垃圾回收

​		JavaScript 通过自动内存管理实现内存分配和闲置资源回收。

​		基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序**每隔一定时间**（或者说在代码执行过程中某个预定的收集时间）就会自动运行。因为无法判定哪块内存是否还在用，无法靠算法解决。

### 4.3.1 标记清理

​		最常用的垃圾回收策略。比如：

- 在函数内部声明一个变量，即变量进入函数上下文，变量会**加上存在于上下文中的标记**；
- 在函数执行期间，不会释放内存；
- 函数执行结束，即变量离开函数上下文，会**加上离开上下文的标记**；
- 下次垃圾回收，会销毁带离开标记的所有值并收回内存。

### 4.3.2 引用计数

​		不常用的垃圾回收策略。思路是：记录引用次数。

- 声明变量并赋一个引用值时，值的引用数为1；
- 如该同一值变量赋值给另一个变量，引用数+1；
- 如该同一值变量被其他值覆盖，引用数-1；
- 当引用数为0时，说明没办法再访问这个值，可安全收回内存；
- 垃圾回收程序下次运行时释放引用数为0的内存。

**严重问题：循环引用**，在标记清除策略下可清除；但在引用计数策略下，由于引用数无法为0，导致无法清除。

解决办法：将变量手动设置成null，切断循环引用的关系。

例子一：DOM对象（element）与原生JS对象（myObject）之间的循环引用。

> ```javascript
>let element = document.getElementById("some_element"); // 1
> let myObject = new Object(); // 1
>myObject.element = element; // element 同一个值被赋给另一个值myObject.element，element引用数+1
> element.someObject = myObject; // myObject 同一个值被赋给另一个值element.someObject，myObject引用数+1
>
> // 切断联系
> myObject.element = null; // myObject被其他值覆盖，myObject引用数-1
> element.someObject = null; // element被其他值覆盖，element引用数-1
> ```

例子二：**两个引用**

现在让我们假设我们将引用从 `user` 复制到 `admin`:

> ```javascript
> // user具有对象的引用
> let user = {
> name: "John"
> };
> 
> let admin = user;
> ```
>
> ![图片描述](https://image-static.segmentfault.com/133/655/133655656-5c9327b57caa3_articlex)
>
> 现在如果我们做同样的事情:
>
> ```javascript
> user = null;
> ```
>
> 该对象仍然可以通过 `admin` 全局变量访问，所以它在内存中。如果我们也覆盖`admin`，那么它可以被释放。

### 4.3.3 性能

​		如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。

​		V8做法：在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量、外加一些余量来确定何时再次垃圾回收。

### 4.3.4 内存管理

​		将内存占用量保持在一个较小的值可以让页面性能更好。

- 全局变量或全局对象的属性：不需要时设置为null，**解除引用**；
- 局部变量在超出作用域后会自动解除引用。

优化方式：

1. 通过const和let声明提升性能
   
   1. ES6增加这俩字段有助于垃圾回收；因为const和let都以块（不是函数）为作用域，比var更早进入回收。
2. 隐藏类和删除操作
   1. 不同实例会共享同一个构造函数和原型，有助于性能优化；
   2. 新增和删除，这种动态属性赋值，会破坏隐藏类；
   3. 新增：尽量在构造函数中一次性声明所有属性，避免“先创建再补充”；
   4. 删除：将不想要的属性设置为null，少使用delete 直接删除；

3. 内存泄漏

   1. 声明全局变量，会导致内存泄漏；

   2. 定时器：回调函数通过闭包引用外部变量；

   3. 闭包；

   4. 静态分配与对象池：

      1. 多使用一个对象去管理属性，不会频繁触发垃圾回收探测；
      2. 多使用已有的对象，比如将以后对象传参至函数，而不是新创建；

      ```javascript
      // 定时器：
      let name = 'Jake';
      setInterval(() => {
      console.log(name);
      }, 100);
      // 只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。
      
      // 闭包：
      let outer = function() {
        let name = 'Jake';
        return function() {
        return name;
        };
      };
      // 调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。
      ```

------

## 4.4 小结

1. 变量保存两类值：原始值和引用值；
2. 原始值大小固定，保存在栈内存；
3. 引用值是对象，保存在堆内存；
4. 执行上下文分全局上下文、函数上下文和块级上下文；
5. JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。 JavaScript 的垃圾回收程序可以总结如下。
    离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
    主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
    引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。 JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）

------

## 4.5 参考资料

1. [前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)

